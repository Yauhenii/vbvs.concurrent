% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/vbvs_concurrent.R
\name{vbvs_concurrent}
\alias{vbvs_concurrent}
\title{vbvs_concurrent}
\usage{
vbvs_concurrent(formula, id.var = NULL, data = NULL, Kt = 5, Kp = 2,
  v0 = 0.01, v1 = 100, standardized = FALSE, t.min = NULL,
  t.max = NULL)
}
\arguments{
\item{formula}{formula for desired regression. should have form \code{ y ~ x1 + x2 + ... + x_k | t}, where \code{t} is the variable that parameterized observed functions}

\item{id.var}{variable giving subject ID vector}

\item{data}{optional data frame}

\item{Kt}{number of spline basis functions for coefficients and FPCs}

\item{Kp}{number of FPCs to estimate}

\item{v0}{tuning parameter; normal spike variance}

\item{v1}{tuning parameter; normal slab variance}

\item{standardized}{logical; are covariates already standardized?}

\item{t.min}{minimum value to be evaluated on the time domain (useful if data are sparse and / or irregular). if `NULL`, taken to be minium observed value.}

\item{t.max}{maximum value to be evaluated on the time domain (useful if data are sparse and / or irregular). if `NULL`, taken to be minium observed value.}
}
\description{
Implements variational bayes variable selection for the linear functional concurrent model
}
\examples{
\dontrun{
library(dplyr)
library(tidyr)
library(ggplot2)

## set design elements
set.seed(1)
I = 100
p = 50

## coefficient functions
beta1 = function(t) { sin(2*t*pi) }
beta2 = function(t) { cos(2*t*pi) }
beta3 = function(t) { 1 }

## FPC basis functions
psi1 = function(t) { sin(4*t*pi) }
psi2 = function(t) { cos(4*t*pi) }

## generate subjects, observation times, and FPC scores
time.data = sapply(1:I, function(u) {
  ji = sample(10:15, 1)
  rbind(runif(ji, 0, 1) \%>\% sort,
        rep(u, ji),
        rep(rnorm(1, 0, 3), ji),
        rep(rnorm(1, 0, 1), ji))
}) \%>\% unlist() \%>\% matrix(ncol = 4, byrow = TRUE)
colnames(time.data) = c("time", "subj", "c_i1", "c_i2")
time.data = as.data.frame(time.data)

## generate predictor data
predictor.data = matrix(rnorm(dim(time.data)[1] * p), dim(time.data)[1], p)
colnames(predictor.data) = paste0("Cov_", 1:p)

## combine and generate responses
concurrent.data = cbind(time.data, predictor.data)
concurrent.data =
  mutate(concurrent.data,
         Y = Cov_1 * beta1(time) +            ## fixed effects
             Cov_2 * beta2(time) +
             Cov_3 * beta3(time) +
             c_i1 * psi1(time) +              ## pca effects
             c_i2 * psi2(time) +
             rnorm(dim(concurrent.data)[1]))  ## measurement error

## fit model
pred.list = paste("Cov", 1:p, sep = "_")
formula = as.formula( paste("Y ~", paste(pred.list, collapse = "+"), "| time") )
fit.vbvs = vbvs_concurrent(formula, id.var = "subj", data = concurrent.data, standardized = TRUE,
                           t.min = 0, t.max = 1)

## some plots
plot(fit.vbvs$gamma.pm)

betaHat = coef(fit.vbvs, t.new = seq(0, 1, length = 50)) \%>\%
  gather(., Cov, Value, -t)
betaTrue = data.frame(t = seq(0, 1, length = 50),
                      beta1 = beta1(seq(0, 1, length = 50)),
                      beta2 = beta2(seq(0, 1, length = 50)),
                      beta2 = beta3(seq(0, 1, length = 50))) \%>\%
  gather(., Cov, Value, -t)

ggplot(betaHat, aes(x = t, y = Value, group = Cov)) + geom_path() +
  geom_path(data = betaTrue, color = "red") + theme_bw()
}
}
\author{
Jeff Goldsmith \email{jeff.goldsmith@columbia.edu}
}

